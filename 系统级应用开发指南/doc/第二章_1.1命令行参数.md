## gflags

gflags是google的一个开源的处理命令行参数的库，使用c++开发，可以替代getopt。gflags使用起来比getopt方便，但是不支持参数的简写。

### 使用入门
gflags中使用宏来定义加载的对应的命令行参数，基本格式如下：
```
DEFINE_xxxxx(变量名，默认值，help-string)
```
gflag中支持的命令行参数类型有一下几种:
```
DEFINE_bool: boolean
DEFINE_int32: 32-bit integer
DEFINE_int64: 64-bit integer
DEFINE_uint64: unsigned 64-bit integer
DEFINE_double: double
DEFINE_string: C++ string
DEFINE_VARIABLE
DEFINE_validator
```
基本的使用示例：
- 添加头文件
```
#include <gflags/gflags.h>
```

- 添加参数定义
  ```
    DEFINE_int32(port, 2181, "port")
  ```

- main函数中加入处理代码，并使用命令行参数
```
google::ParseCommandLineFlags(&argc, &argv, true);
printf("%s", FLAGS_mystr);
```
> 注意：使用完成后关闭google:ShutDownCommandLineFlags();避免内存泄露。

这里说明下其中的参数信息，argc和argv是命令参数的数目和具体信息，第三个参数用于gflag处理后参数信息的处理：
> true，则该函数处理完成后，argv中只保留argv[0]，argc会被设置为1。
false，则argv和argc会被保留，但是注意函数会调整argv中的顺序。
这样，在后续代码中可以使用FLAGS_变量名访问对应的命令行参数了

gflag的命令行参数不支持短类型，参数格式都是　--xxx=vaue或者--xxx value的形式。bool类型除了可以使用--xxx=true/false之外，还可以使用--xxx和--noxxx后面不加等号的方式指定true和false。

### 高级用法

#### 检验输入参数

gflags库支持定制自己的输入参数检查的函数，如下：
```
static bool ValidatePort(const char* flagname, int32 value) {
   if (value > 0 && value < 32768)   // value is ok
     return true;
   printf("Invalid value for --%s: %d\n", flagname, (int)value);
   return false;
}
DEFINE_int32(port, 0, "What port to listen on");
static const bool port_dummy = RegisterFlagValidator(&FLAGS_port, &ValidatePort);
```

#### 判断flags变量是否被用户使用：
```
    google::CommandLineFlagInfo info;
    if(GetCommandLineFlagInfo("port" ,&info) && info.is_default) {
        FLAGS_port = 27015;
    }
```

#### 定制help信息与version信息
gflags里面已经定义了-h和--version，可以通过以下方式定制它们的内容

version信息：使用google::SetVersionString设定，使用google::VersionString访问

help信息：使用google::SetUsageMessage设定，使用ProgramUsage访问

注意：google::SetUsageMessage和google::SetVersionString必须在ParseCommandLineFlags之前执行

### 示例说明

gflag语法很简单，使用起来也很方便，这里给出mesos-master命令行参数的一些简单信息。
首先安装对应的开发库，以ubuntu14.04为例
```
sudo apt-get install libgflags-dev
```
添加option.h文件，用于命令行参数的定义和处理
```c++
#include <iostream>

#include <gflags/gflags.h>

using namespace std;

DEFINE_int32(port, 0, "What port to listen on");

bool ValidatePort(const char* flagname, int32_t value) {
    if (value > 0 && value<32768)   // value is ok
        return true;
    cout << "Invalid value for --" << flagname << " " << (int)value << endl;
    return false;
}

int mainOption(int argc, char *argv[]) {
    std::string usage("This program does nothing.  Sample usage:\n");
    usage += std::string(argv[0])+" --port 1234 \n or :\n -flagfile=foo.conf";
    google::SetUsageMessage(usage);
    gflags::SetVersionString("1.0.0");
    
    google::RegisterFlagValidator (&FLAGS_port, ValidatePort);
}
```
main
 
``` c++
#include <iostream>
#include <cmath>
#include "demo_config.h"
#include "./option/option.h"

using namespace std;

int main(int argc, char *argv[]) {

    mainOption(argc, argv);
    google::ParseCommandLineFlags (&argc, &argv, false);

    cout << FLAGS_port << endl;
    
    google:ShutDownCommandLineFlags();
    return 0;
}
```
编译执行，链接库中添加gflags库
```
target_link_libraries (${PROJECT_NAME} gflags)
```
### cmake中使用在线安装方式构建
在cmake中使用已安装的二进制包时，只需要在编译时确认所需要的安装包已经安装完成。CMake使用find_package命令来查找外部库的头文件地址和链接库的地址。基本的使用流程如下：
- 1、find_package
- 2、编写 FindXxxx.cmake文件，写明具体的查找流程，这里使用find_path、find_library来查找对应的头文件和库文件地址。

下面分别看一下find_package和编写FindName.cmake文件的详细过程。
#### find_package流程
find_package基本语法：
```
FIND_PACKAGE( <name> [version] [EXACT] [QUIET] [NO_MODULE] [ [ REQUIRED | COMPONENTS ] [ componets... ] ] )
```
这条命令执行后，CMake 会到变量 CMAKE_MODULE_PATH 指示的目录中查找文件 Findname.cmake并执行。当然也可以自己定义Find<name>模块，将其放入工程的某个目录中，通过 SET(CMAKE_MODULE_PATH dir)设置查找路径，供工程FIND_PACKAGE使用。

参数说明：
- name: 查找的lib库名称；
- version:版本号，它是正在查找的包应该兼容的版本号（格式是major[.minor[.patch[.tweak]]]）；
- EXACT选项要求版本号必须精确匹配。如果在find-module内部对该命令的递归调用没有给定[version]参数，那么[version]和EXACT选项会自动地从外部调用前向继承；
- QUIET：会禁掉包没有被发现时的警告信息。对应于Find<name>.cmake模块中的 name_FIND_QUIETLY；
> 注意：name必须完全一致，包括大小写
- REQUIRED： 其含义是指是否是工程必须的，表示如果报没有找到的话，cmake的过程会终止，并输出警告信息。对应于Find<name>.cmake模块中的 name_FIND_REQUIRED变量；
> 注意：name必须完全一致，包括大小写
- COMPONENTS在REQUIRED选项之后，或者如果没有指定REQUIRED选项但是指定了COMPONENTS选项，在它们的后面可以列出一些与包相关（依赖）的部件清单（components list）；

例如：
```
find_package(Gflag REQUIRED)
```
#### 编写查找模块 Findname.cmake
查找模块的命名Find<name>.cmake,name必须和find_package中的name保持一致。

编写查找模块的基本步骤：
- 1、定义查找的lib库名，例如gflags
- 2、查找头文件目录和lib库文件目录，并判断查找结果

FindGflag.cmake文件如下：
```
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

###############################################################
# IMPORTANT NOTE: I (hausdorff) have copied a *lot* of stuff in this file from
#                 code I found at in the Akumuli[1] project. The original version
#                 of this file was also released under the Apache 2.0 license, and
#                 licensed to the ASF, making it fully compatible with the Mesos
#                 project.
#  [1] https://github.com/akumuli/Akumuli/blob/master/cmake/FindAPR.cmake
# This module helps to find the Apache Portable Runtime (APR) and APR-Util
# packages.
#
# USAGE: to use this module, add the following line to your CMake project:
#   find_package(Apr)
#############################################################################

if (GFLAG_FOUND)
  return()
endif (GFLAG_FOUND)

unset(GFLAG_LIB)
unset(GFLAG_INCLUDE_DIR)
unset(GFLAG_LIBS)

# NOTE: If this fails, stderr is ignored, and the output variable is empty.
# This has no deleterious effect our path search.
execute_process(
  COMMAND brew --prefix gflags
  OUTPUT_VARIABLE GFLAG_PREFIX
  OUTPUT_STRIP_TRAILING_WHITESPACE)

set(POSSIBLE_GFLAG_INCLUDE_DIRS
  ${POSSIBLE_GFLAG_INCLUDE_DIRS} 
  /usr/local/include/gflags 
  /usr/include/gflags
)

set(GFLAG_LIB_NAMES ${GFLAG_LIB_NAMES} gflags)

set(POSSIBLE_GFLAG_LIB_DIRS
  ${POSSIBLE_GFLAG_LIB_DIRS} 
  /usr/local/gflags/lib
  /usr/local/lib
  /usr/lib
  )

# SEARCH FOR GFLAG LIBRARIES.
###########################
find_path(GFLAG_INCLUDE_DIR gflags.h ${POSSIBLE_GFLAG_INCLUDE_DIRS})

find_library(
  GFLAG_LIB
  NAMES ${GFLAG_LIB_NAMES}
  HINTS ${POSSIBLE_GFLAG_LIB_DIRS}
  )

# Did we find the include directory?
string(
  COMPARE NOTEQUAL
  "GFLAG_INCLUDE_DIR-NOTFOUND"
  ${GFLAG_INCLUDE_DIR} # Value set to GFLAG_INCLUDE_DIR-NOTFOUND if not found.
  GFLAG_INCLUDE_DIR_FOUND
  )

# Did we find the library?
string(
  COMPARE NOTEQUAL
  "GFLAG_LIB-NOTFOUND"
  ${GFLAG_LIB} # Value set to `GFLAG_LIB-NOTFOUND` if not found.
  GFLAG_LIB_FOUND
  )

# GFLAG is considered "found" if we've both an include directory and an GFLAG binary.
if ("${GFLAG_LIB_FOUND}" AND "${GFLAG_INCLUDE_DIR_FOUND}")
  set(GFLAG_LIBS ${GFLAG_LIB})
  set(GFLAG_FOUND 1)
else ("${GFLAG_LIB_FOUND}" AND "${GFLAG_INCLUDE_DIR_FOUND}")
  set(GFLAG_FOUND 0)
endif ("${GFLAG_LIB_FOUND}" AND "${GFLAG_INCLUDE_DIR_FOUND}")

# Results.
if (GFLAG_FOUND)
  if (NOT GFLAG_FIND_QUIETLY)
    message(STATUS "Found GFLAG headers: ${GFLAG_INCLUDE_DIR}")
    message(STATUS "Found GFLAG library: ${GFLAG_LIBS}")
  endif (NOT GFLAG_FIND_QUIETLY)
else (GFLAG_FOUND)
  if (Gflag_FIND_REQUIRED)
    message(FATAL_ERROR "Could not find GFLAG library")
  endif (Gflag_FIND_REQUIRED)
endif (GFLAG_FOUND)

# (Deprecated declarations.)
set(NATIVE_GFLAG_INCLUDE_PATH ${GFLAG_INCLUDE_DIR} )
get_filename_component(NATIVE_GFLAG_LIB_PATH ${GFLAG_LIB} PATH)

# Export libraries variables.
mark_as_advanced(
  GFLAG_LIB
  GFLAG_INCLUDE_DIR
  )
```
查找到的结果，在最终编译时分别追加到${TARGET_INCLUDE_DIRS}、${TARGET_LIB_DIRS}、${TARGET_LIBS}变量下。

### cmake中使用源码构建
使用源码构建具体的过程参考，第一章CMake实践指南，这里要注意的是使用源码构建之前，可以单独源码编译一下对应的代码库，确定下编译时需要的一些参数和配置信息。
3rdparty/CMakeLists.txt
```
include(ExternalProject)

# Define build/patch/configure commands for third-party libs.
#############################################################
if (NOT WIN32)
  set(GLOG_CONFIG_CMD  ${GLOG_ROOT}/src/../configure --prefix=${GLOG_LIB_ROOT})
  set(GLOG_BUILD_CMD   make libglog.la)
  set(GLOG_INSTALL_CMD make install)
  PATCH_CMD(${3RDPARTY_SRC}/glog-0.3.3.patch GLOG_PATCH_CMD)
  
  set(GFLAGS_BUILD_CMD   make)  
  set(GFLAGS_INSTALL_CMD make install)
 
elseif (WIN32)
  set(GLOG_INSTALL_CMD ${CMAKE_NOOP})

endif (NOT WIN32)

# Third-party libraries. Tell the build system how to pull in and build third-
# party libraries at compile time, using the ExternalProject_Add macro.
##############################################################################
ExternalProject_Add(
  ${GLOG_TARGET}
  PREFIX            ${GLOG_CMAKE_ROOT}
  CMAKE_ARGS        -DBUILD_SHARED_LIBS=OFF -DCMAKE_CXX_FLAGS_DEBUG=${CMAKE_CXX_FLAGS_DEBUG}
  PATCH_COMMAND     ${GLOG_PATCH_CMD}
  CONFIGURE_COMMAND ${GLOG_CONFIG_CMD}
  BUILD_COMMAND     ${GLOG_BUILD_CMD}
  INSTALL_COMMAND   ${GLOG_INSTALL_CMD}
  URL               ${GLOG_URL}
  DOWNLOAD_NAME     glog-${GLOG_VERSION}.tar.gz
)

ExternalProject_Add(
  ${GFLAGS_TARGET}
  PREFIX            ${GFLAGS_CMAKE_ROOT}
  BUILD_COMMAND     ${GFLAGS_BUILD_CMD} 
  INSTALL_COMMAND   ${GFLAGS_INSTALL_CMD} 
  URL               ${GFLAGS_URL}
  DOWNLOAD_NAME     gflags-${GFLAGS_VERSION}.tar.gz
)
```

3rdparty/cmake/3rdpartyConfigure.cmake
> 第三方库基本信息配置，第三方库编译信息信息以及最终编译目标库的头文件地址、链接库地址信息、连接库名称、第三方依赖库信息等。

```
message(STATUS "************************************************************")
message(STATUS "*******************3rd party Configure**********************")
message(STATUS "************************************************************")

# DEFINE DIRECTORY STRUCTURE FOR THIRD-PARTY LIBS.
##################################################
set(3RDPARTY_SRC ${CMAKE_SOURCE_DIR}/3rdparty)
set(3RDPARTY_BIN ${CMAKE_BINARY_DIR}/3rdparty)

# DEPENDENCIES
#
# Downloads, configures, and compiles the third-party libraries
###############################################################################
if (NOT WIN32)
  EXTERNAL("glog" ${GLOG_VERSION} "${3RDPARTY_BIN}")
  EXTERNAL("gflags" ${GFLAGS_VERSION} "${3RDPARTY_BIN}")
elseif (WIN32)
  # Glog 0.3.3 does not compile out of the box on Windows. Therefore, we
  # require 0.3.4.
  EXTERNAL("glog" "0.3.4" "${3RDPARTY_BIN}")

  # NOTE: We expect cURL and zlib exist on Unix (usually pulled in with a
  # package manager), but Windows has no package manager, so we have to go
  # get it.
  EXTERNAL("curl" ${CURL_VERSION} "${3RDPARTY_BIN}")

  EXTERNAL("zlib" ${ZLIB_VERSION} "${3RDPARTY_BIN}")
endif (NOT WIN32)

# Intermediate convenience variables for oddly-structured directories.
set(GLOG_LIB_ROOT     ${GLOG_ROOT}-lib/lib)
set(GFLAGS_LIB_ROOT   ${GFLAGS_ROOT}-lib/lib)

# Define sources of third-party dependencies.
#############################################
set(UPSTREAM_URL ${3RDPARTY_DEPENDENCIES})
set(REBUNDLED_DIR ${CMAKE_CURRENT_SOURCE_DIR})

if (REBUNDLED) 
  set(GLOG_URL        ${REBUNDLED_DIR}/3rdparty/glog-${GLOG_VERSION}.tar.gz) 
  set(GFLAGS_URL      ${REBUNDLED_DIR}/3rdparty/gflags-${GFLAGS_VERSION}.tar.gz)
else (REBUNDLED) 
  set(GLOG_URL        ${UPSTREAM_URL}/glog-${GLOG_VERSION}.tar.gz)
  set(GFLAGS_URL      ${UPSTREAM_URL}/gflags-${GFLAGS_VERSION}.tar.gz)
else (REBUNDLED) 
endif (REBUNDLED)

# Binary lib
# find_package(Gflag REQUIRED)

# Convenience variables for `lib` directories of built third-party dependencies.
if (WIN32)
  set(GLOG_LIB_DIR        ${GLOG_ROOT}-build/${CMAKE_BUILD_TYPE})
  set(GFLAGS_LIB_DIR      ${GFLAGS_ROOT}-build/lib)
else (WIN32)
  set(GLOG_LIB_DIR        ${GLOG_LIB_ROOT}/lib)
  set(GFLAGS_LIB_DIR      ${GFLAGS_ROOT}-build/lib)
endif (WIN32)

# Convenience variables for "lflags", the symbols we pass to CMake to generate
# things like `-L/path/to/glog` or `-lglog`.
set(GLOG_LFLAG        glog)
set(GFLAGS_LFLAG      gflags)

# Convenience variables for include directories of third-party dependencies.
if (WIN32)
  set(GLOG_INCLUDE_DIR     ${GLOG_ROOT}/src/windows)
  set(GFLAGS_INCLUDE_DIR   ${GFLAGS_ROOT}-build/include)
else (WIN32)
  set(GLOG_INCLUDE_DIR     ${GLOG_LIB_ROOT}/include)
  set(GFLAGS_INCLUDE_DIR   ${GFLAGS_ROOT}-build/include)
endif (WIN32)

# DEFINE LIBRARY DEPENDENCIES. Tells the process library build targets
# download/configure/build all third-party libraries before attempting to build.
################################################################################
set(TARGET_DEPENDENCIES
  ${TARGET_DEPENDENCIES}
  ${GLOG_TARGET}
  ${GFLAGS_TARGET}
)

# Target lib
set(TARGET_LIBS
  ${TARGET_LIBS}
  ${GLOG_LFLAG}
  ${GFLAGS_LFLAG}
)

# Target include dirs
set(TARGET_INCLUDE_DIRS
  ${TARGET_INCLUDE_DIRS}
  ${GLOG_INCLUDE_DIR}
  ${GFLAGS_INCLUDE_DIR}
)

# Target include lib dirs
set(TARGET_LIB_DIRS
  ${TARGET_LIB_DIRS}
  ${GLOG_LIB_DIR}
  ${GFLAGS_LIB_DIR}
)

message(STATUS "INCLUDE DIR: ${TARGET_INCLUDE_DIRS}")
message(STATUS "TARGET LIB DIR: ${TARGET_LIB_DIRS}")
message(STATUS "TARGET_DEPENDENCIES: ${TARGET_DEPENDENCIES}")
message(STATUS "TARGET_LIBS: ${TARGET_LIBS}")

message(STATUS "************************************************************")
```
### 参考资料：
> https://gflags.github.io/gflags/

> https://github.com/schuhschuh/gflags/releases

