# 开发规范
向社区贡献代码
## 代码风格说明

一般的风格可以参考google c++编码规范，mesos源码遵循google c++编码的相关规范。同时添加了一些不同点，这里对常用的几个规范进行说明。具体的一些细节可以查看参考资料中的相关内容。

### 异同

* 缩进：类中的Access modifiers不缩进，google使用一个空格
* 模板: template <typename T>
* 变量名:驼峰

```
Try(State _state, T* _t = NULL, const std::string& _message = "")
  : state(_state), t(_t), message(_message) {}

常量名，例如
SCREAMING_SNAKE_CASE
```
* 函数调用：

```
// 1: OK.
allocator->resourcesRecovered(frameworkId, slaveId, resources, filters);

// 2: Don't use.
allocator->resourcesRecovered(frameworkId, slaveId,
                              resources, filters);

// 3: Don't use in this case due to "jaggedness".
allocator->resourcesRecovered(frameworkId,
                              slaveId,
                              resources,
                              filters);

// 3: In this case, 3 is OK.
foobar(someArgument,
       someOtherArgument,
       theLastArgument);

// 4: OK.
allocator->resourcesRecovered(
    frameworkId,
    slaveId,
    resources,
    filters);

// 5: OK.
allocator->resourcesRecovered(
    frameworkId, slaveId, resources, filters);
```
* 变量多行赋值,第二行两格空格
```
Try<Duration> failoverTimeout =
  Duration::create(FrameworkInfo().failover_timeout());
```

* 空行：在多个逻辑块之间使用一行空行，类或结构体之间使用两行空行
* 禁止使用模板引用

```
Future<Nothing> f() { return Nothing(); }
Future<bool> g() { return false; }

struct T
{
  T(const char* data) : data(data) {}
  const T& member() const { return *this; }
  const char* data;
};

// 1: Don't use.
const Future<Nothing>& future = f();

// 1: Instead use.
const Future<Nothing> future = f();

// 2: Don't use.
const Future<Nothing>& future = Future<Nothing>(Nothing());

// 2: Instead use.
const Future<Nothing> future = Future<Nothing>(Nothing());

// 3: Don't use.
const Future<bool>& future = f().then(lambda::bind(g));

// 3: Instead use.
const Future<bool> future = f().then(lambda::bind(g));

// 4: Don't use (since the T that got constructed is a temporary!).
const T& t = T("Hello").member();

// 4: Preferred alias pattern (see below).
const T t("Hello");
const T& t_ = t.member();

// 4: Can also use.
const T t = T("Hello").member();
```

* 头文件的先后次序

头文件的先后此

Example for src/common/foo.cpp:
```
#include "common/foo.hpp"

#include <stdint.h>

#include <string>
#include <vector>

#include <boost/circular_buffer.hpp>

#include <mesos/mesos.hpp>
#include <mesos/type_utils.hpp>

#include <mesos/module/authenticator.hpp>

#include <mesos/scheduler/scheduler.hpp>

#include <process/http.hpp>
#include <process/protobuf.hpp>

#include <stout/foreach.hpp>
#include <stout/hashmap.hpp>

#include "common/build.hpp"
#include "common/protobuf_utils.hpp"

#include "master/flags.hpp"

```

参考文章：

http://pan.baidu.com/s/1i3gc7lF

https://mesos.apache.org/documentation/latest/c++-style-guide/

https://issues.apache.org/jira/browse/MESOS-2629