# 1.1 CMake使用指南

CMake用于跨平台的编译系统，对于通常的c/c++工程，都是通过make来进行编译的，CMake可以通过指令生成Makefile文件来指导整个项目的编译过程。CMake项目组还有其他的工具来完成项目的打包部署以及测试。

## 1.1.1 Make使用说明

Make是最常用的构建工具，主要用于C/C++语言的项目。make编译命令通过Makefile文件来构建整个工程。

对于简单的helloworld.cpp这样的代码，直接通过g++编译指令接可以完成项目的构建过程。例如：
``` c++
#include <iostream>
using namespace std;

int main(int argc, char *argv[]) {

	cout << "Hello  World!!" << endl;
	return 0;

}
```
编译生成并可执行可执行文件helloworld
```
g++ -o helloworld helloworld.cpp
./helloworld
```
但是对于稍微大一点的项目，每次都使用个g++来编译，显然不能满足实际开发的需求。那能否通过编写脚本来处理整个项目构建的过程呢？make使用Makefile中的规则来指导编译过程，从而避免每次去编写编译脚本。

Makefile文件由一系列规则构成，每条规则的基本格式如下：
```
<target> : <prerequisites> 
[tab]  <commands>
```
构建的规则指明构建的依赖条件以及构建的具体执行过程。规则中首先申明构建的目标和前置条件，目标可以是文件也可以是指令，前置条件通常是文件，用于说明创建目标target之前必须要更新的文件。第二行写明执行的命令，注意的是必须有tab键。"目标"是必需的，不可省略；"前置条件"和"命令"都是可选的，但是两者之中必须至少存在一个。

上例的过程就使用Ｍakefile规则来说明如下：
```
helloworld:
    g++ -o helloworld helloworld.cpp
```
构建执行：
```
make hellowolrd   //生成目标
./helloworld　　　//执行目标文件
```
Makefile中还可以使用基本的指令，以及shell脚本来控制整个项目构建过程。关于这方面详细的内容不再讲解，读者可以参考参考教程中给出的文章。这里给出一个git上的一个比较全面的Makefile示例文件:

https://gist.github.com/isaacs/62a2d1825d04437c6f08

正如示例开头所讲make非常强大，但是其语法并十分友好，同时对大的项目中每次去编写Makefile文件也是很头大的事儿。而CMake却可以通过简单的指令来帮助程序开发人员生成Makefile文件。

> 参考教程：
> 
http://www.ruanyifeng.com/blog/2015/02/make.html
https://www.gnu.org/software/make/manual/make.html


## 1.1.2 CMake使用指南

CMake是一个跨平台的、开源的make系统。CMake使用编译器独立的脚本来生成Makefile文件，完成项目编译过程。CMake使用脚本文件来生成Ｍakefile文件，通常CMakeLists.txt。当然CMakeLists.txt并不是只用于项目构建，也可以用于CPack、CTest等过程。

CMake中包括了内置变量、控制指令、变量以及Message四种语法，涉及的内容很多。这里不再详细说明其语法，通过实际的几个应用场景来说明具体的使用方法。
### HelloWorld
仍然以上例中的HelloWorld作为例子,这里先给出项目的代码结构
```
helloworld1
  build
  src
    main.cpp
  CMakeLists.txt
```
CMakeLists.txt
```
# THE HEllOWORLD PROJECT.
####################
cmake_minimum_required(VERSION 2.8)

project(helloworld)

aux_source_directory(./src SRC_LIST)
add_executable(${PROJECT_NAME} ${SRC_LIST})
```
编译运行
```
cd build
cmake ..
make
./helloworld
```
本例中CMakeLists.txt中，给出了工程名以及需要的cmake版本，第三行给出了依赖的源文件，这里是./src下的所有.hpp .h .cpp .c .hxx格式的文件，第四行给出了编译的目标文件和依赖的源文件。

示例代码下载地址：
http://pan.baidu.com/s/1dF2Sf0d
### 添加配置信息
在实际的工程项目中，版本迭代的速度很快，可以通过脚本来添加版本信息。CMake将对应的版本信息，写到对应的配置头文件中。
```
# THE HEllOWORLD PROJECT.
####################
cmake_minimum_required(VERSION 2.8)

project(helloworld)

set(HELLOWORLD_VERSION_MAJOR 0)
set(HELLOWORLD_VERSION_MINOR 28)
set(HELLOWORLD_PATCH_VERSION 0)
set(PACKAGE_VERSION  ${MESOS_VERSION_MAJOR}.${MESOS_VERSION_MINOR}.${MESOS_PATCH_VERSION})
set(HELLOWORLD_PACKAGE_VERSION ${PACKAGE_VERSION})
set(HELLOWORLD_PACKAGE_SOVERSION 0)

#　Configuration
##################
configure_file (
  "${PROJECT_SOURCE_DIR}/demo_config.h.in"
  "${PROJECT_BINARY_DIR}/demo_config.h"
)
include_directories("${PROJECT_BINARY_DIR}")

aux_source_directory(./src SRC_LIST)
add_executable(${PROJECT_NAME} ${SRC_LIST})
```
创建对应的配置文件：demo_config.h.in
```
#define HELLOWORLD_VERSION_MAJOR @HELLOWORLD_VERSION_MAJOR@
#define HELLOWORLD_VERSION_MINOR @HELLOWORLD_VERSION_MINOR@
```
在main.cpp中使用配置文件：
```
#include <iostream>
#include "demo_config.h"
using namespace std;

int main(int argc, char *argv[]) {
    cout << argv[0] << " Version is " <<            HELLOWORLD_VERSION_MAJOR << "." << 
            HELLOWORLD_VERSION_MINOR << endl;
    cout << "Hello  World!!" << endl;
    return 0;

}
```
编译运行过程同上，这里也给出工程的代码结构如下：
```
helloworld2
  build
  src
    main.cpp
  CMakeLists.txt
  demo_config.h.in
```
### 添加代码库
通常会将自己的工程按照不同的工程模块组织起来，不同的模块会编译成不同的目标文件，最后通过链接形成最终的目标文件。在src目录下添加一个demo文件夹，并添加demo_math.h demo_math.cpp文件。并在该目录下创建CMakeLists.txt
```
add_library(mathfunction demo_math.cpp)
```
为了整个工程中能找到对应的目录，需要在整个工程的CMakeLists.txt添加引入指令。
```
include_directories ("${PROJECT_SOURCE_DIR}/src/demo")
add_subdirectory (./src/demo) 
```
以上的语句引入demo下的源码，并将其添加到编译目录下，以便编译的时候能找到对应的原型文件。同时这里将对应的源码编译成对应的库文件。最后在目标文件中，链接编译的动态库。
```
add_executable (helloworld SRC_LIST)
target_link_libraries (helloworld mathfunction)
```
编译运行，这里也给出代码的结构，后续的不再赘述：
```
helloworld2
  build
  src
    demo
      CMakeLists.txt
      demo_math.h
      demo_math.cpp
    main.cpp
  CMakeLists.txt
  demo_config.h.in
```
使用系统库也是同样的过程,例如使用math库：
```
target_link_libraries (${PROJECT_NAME} m)
```
### Check
用于对相应系统环境中的一些函数或者环境变量的检测，
```
include (CheckFunctionExists)
check_function_exists (log HAVE_LOG)
check_function_exists (exp HAVE_EXP)
```
check的结果可以在demo_config.h.in中来定义
```
#cmakedefine HAVE_LOG
#cmakedefine HAVE_EXP
```
### 第三方库管理

使用第三方库可以通过直接链接已经编译好的开发库。使用编译好的库时，可以通过find_library来查找系统路径中的库代码。使用发布的源码编译时，要将对应的项目加入到编译目录下。
```
if (EXISTS "${PROJECT_SOURCE_DIR}/gflags/CMakeLists.txt")
  add_subdirectory(gflags)
else ()
  find_library(gflags REQUIRED)
endif ()
```
也可以通过网络来
### 安装
安装代码
```
install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)
```
使用该指令，make install会将对应的目标文件copy到/usr/local/bin目录下，把头文件copy到/usr/local/include目录下。该目录可以通过CMAKE_INSTALL_PREFIX来设置。
### 测试
CTest一般用于可执行文件的测试，整个项目编译完成后，对整个项目的执行测试。
```
includ(CTest)
add_test (testname 可执行文件 参数列表)　//参数以空格隔开
set_tests_properties (testname
PROPERTIES PASS_REGULAR_EXPRESSION "is 4") //结果验证
```
测试文件也可以通过宏文件来定义
```
#define a macro to simplify adding tests, then use it
macro (do_test arg result)
  add_test (testname${arg} testfun ${arg})
  set_tests_properties (testname${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result})
endmacro (do_test)
 
# do a bunch of result based tests
do_test (25 "25 is 5")
do_test (-25 "-25 is 0")
```
### Package
```
# Package
# build a CPack driven installer package
include (InstallRequiredSystemLibraries)
set (CPACK_RESOURCE_FILE_LICENSE  
     "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set (CPACK_PACKAGE_VERSION_MAJOR "${HELLOWORLD_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR "${HELLOWORLD_VERSION_MINOR}")
include (CPack)
```
CMake完成后，会生成PackConfig文件
```
cpack --config CPackConfig.cmake  //二进制
cpack --config CPackSourceConfig.cmake　//源码
```
### 跨平台

通过开关选项来控制编译参数，并用条件控制指令来选择不同的分支。

```
if (REBUNDLED AND ENABLE_LIBEVENT)
  message(
    WARNING
    "Both `ENABLE_LIBEVENT` and `REBUNDLED` (set to TRUE by default) flags "
    "have been set. But, libevent does not come rebundled in Mesos, so it must "
    "be downloaded."
    )
endif (REBUNDLED AND ENABLE_LIBEVENT)

if (WIN32 AND REBUNDLED)
  message(
    WARNING
    "The current supported version of ZK does not compile on Windows, and does "
    "not come rebundled in the Mesos repository. It must be downloaded from "
    "the Internet, even though the `REBUNDLED` flag was set."
    )
endif (WIN32 AND REBUNDLED)

if (WIN32 AND (NOT ENABLE_LIBEVENT))
  message(
    FATAL_ERROR
    "Windows builds of Mesos currently do not support libev, the default event "
    "loop used by Mesos. To opt into using libevent, pass "
    "`-DENABLE_LIBEVENT=1` as an argument when you run CMake. NOTE: although "
    "the plan is to eventually transition to libevent, it is still in "
    "experimental support, and the code path is much less well-exercised."
    )
endif (WIN32 AND (NOT ENABLE_LIBEVENT))
```
### 完整的示例
```
# THE HEllOWORLD PROJECT.
####################
cmake_minimum_required(VERSION 2.8)

project(helloworld)

set(HELLOWORLD_VERSION_MAJOR 0)
set(HELLOWORLD_VERSION_MINOR 28)
set(HELLOWORLD_PATCH_VERSION 0)
set(PACKAGE_VERSION  ${MESOS_VERSION_MAJOR}.${MESOS_VERSION_MINOR}.${MESOS_PATCH_VERSION})
set(HELLOWORLD_PACKAGE_VERSION ${PACKAGE_VERSION})
set(HELLOWORLD_PACKAGE_SOVERSION 0)

# Check
include (CheckFunctionExists)
check_function_exists (log HAVE_LOG)
check_function_exists (exp HAVE_EXP)

#　Configuration
##################
configure_file (
  "${PROJECT_SOURCE_DIR}/demo_config.h.in"
  "${PROJECT_BINARY_DIR}/demo_config.h"
)
include_directories("${PROJECT_BINARY_DIR}")

# Module or Lib
include_directories ("${PROJECT_SOURCE_DIR}/src/demo")
add_subdirectory (./src/demo) 

# Compile
aux_source_directory(./src SRC_LIST)

set_target_properties(
  ${PEOJECT_NAME} PROPERTIES
  VERSION ${HELLOWORLD_PACKAGE_VERSION}
  SOVERSION ${HELLOWORLD_PACKAGE_SOVERSION}
)

add_executable(${PROJECT_NAME} ${SRC_LIST})

target_link_libraries (${PROJECT_NAME} mathfunction)
target_link_libraries (${PROJECT_NAME} m)

# Install
install (TARGETS ${PROJECT_NAME} DESTINATION bin)

# Test
include(CTest)
add_test (test1 ${PROJECT_NAME})
set_tests_properties (test1 
PROPERTIES PASS_REGULAR_EXPRESSION "Version is 0.28") 


# Package
# build a CPack driven installer package
include (InstallRequiredSystemLibraries)
set (CPACK_RESOURCE_FILE_LICENSE  
     "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set (CPACK_PACKAGE_VERSION_MAJOR "${HELLOWORLD_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR "${HELLOWORLD_VERSION_MINOR}")
include (CPack)
```
### CMake包管理

CMake包通过项目目录下的.cmake文件来管理，其查找路径可以通过CMAKE_MODULE_PATH来设置：
```
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake")
```
### 其他
* list
list提供列表操作，
list子命令APPEND, INSERT, REMOVE_AT, REMOVE_ITEM,REMOVE_DUPLICATES, REVERSE以及SORT在当前的CMake变量域创建一些新值。
```
list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/3rdparty/cmake)
```
* 添加编译器参数  
set(CMAKE_CXX_FLAGS "-Wall　-g") 

* 开关选项cmakedefine

```
option(USE_MYMATH 
  "Use tutorial provided math implementation" ON)
```
使用时在对应的configuretion文件中添加对应的宏定义即可,同时可以作为变量在CMakeLists.txt中使用。
```
#cmakedefine USE_MYMATH
```

* 项目中产生文件

```
# first we add the executable that generates the table
add_executable(MakeTable MakeTable.cxx)
 
# add the command to generate the source code
add_custom_command (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/table.h
  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/table.h
  DEPENDS MakeTable
  )
```
可以通过可执行文件MaekTable来产生table.h头文件

* hpp文件

hpp其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，不需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj,采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，简化了编译过程。很多开源的开发库，例如Boost等，都采用这种方式来编写的。

使用hpp文件缺点是代码对外是完全开放的，所有人都可以看到源码的实现。

使用hpp文件需要注意：

http://baike.baidu.com/subview/3779455/17977377.htm

1、不可包含全局对象和全局函数

由于hpp本质上是作为.h被调用者include，所以当hpp文件中存在全局对象或者全局函数，而该hpp被多个调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。 

2、类之间不可循环调用。
在.h和.cpp的场景中，当两个类或者多个类之间有循环调用关系时，只要预先在头文件做被调用类的声明即可，如下：
```
    class B;
    class A{
    public:
         void someMethod(B b);
    };
    class B{
    public:
         void someMethod(A a);
    };
```
在hpp场景中，由于定义与实现都已经存在于一个文件，调用者必需明确知道被调用者的所有定义，而不能等到cpp中去编译。因此hpp中必须整理类之间调用关系，不可产生循环调用。

3、不可使用静态成员。

静态成员的使用限制在于如果类含有静态成员，则在hpp中必需加入静态成员初始化代码，当该hpp被多个文档include时，将产生符号重定义错误。

> 参考教程
>
https://cmake.org/Wiki/CMake<br>

>https://cmake.org/documentation/<br>

>https://cmake.org/cmake-tutorial/<br>

>http://hahack.com/codes/cmake/

>https://cmake.org/cmake/help/v3.0/
